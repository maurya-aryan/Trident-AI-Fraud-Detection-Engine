"""
Module #3: Malware Scanner
Detects malware in file attachments using:
  1. Dangerous extension check
  2. ClamAV antivirus (optional – graceful fallback)
  3. Office macro detection
  4. PDF JavaScript detection
  5. Suspicious binary patterns
"""
import logging
import re
import zipfile
from pathlib import Path
from typing import Dict, List

logger = logging.getLogger(__name__)

DANGEROUS_EXTENSIONS = {
    ".exe", ".bat", ".cmd", ".scr", ".ps1", ".vbs",
    ".js", ".jar", ".msi", ".dll", ".com", ".pif",
    ".reg", ".hta", ".lnk", ".wsf", ".wsh", ".cpl",
    ".inf", ".sys",
}

SUSPICIOUS_EXTENSIONS = {
    ".zip", ".rar", ".7z", ".gz", ".tar",  # archives that may contain malware
    ".doc", ".docm", ".xls", ".xlsm", ".ppt", ".pptm",  # macro-enabled Office
    ".pdf",
}

# Suspicious byte signatures (hex)
MALWARE_SIGNATURES = [
    (b"MZ", "PE executable header detected"),
    (b"TVqQ", "Base64-encoded PE executable"),
    (b"EICAR", "EICAR antivirus test file"),
    (b"X5O!P%@AP[4\\PZX54(P^)7CC)7}", "EICAR test string"),
]


class MalwareScanner:
    """
    Multi-layer malware / threat scanner for file attachments.
    ClamAV is used when available; all other checks are pure Python.
    """

    def __init__(self):
        self._clamd = None
        self._clamd_available = False
        self._init_clamd()

    def _init_clamd(self) -> None:
        try:
            import pyclamd  # type: ignore

            cd = pyclamd.ClamdNetworkSocket()
            cd.ping()
            self._clamd = cd
            self._clamd_available = True
            logger.info("ClamAV daemon connected successfully.")
        except Exception as exc:
            logger.warning(f"ClamAV not available ({exc}). Using static analysis only.")

    # ------------------------------------------------------------------
    # Internal checks
    # ------------------------------------------------------------------

    def _check_extension(self, path: Path) -> List[str]:
        reasons: List[str] = []
        ext = path.suffix.lower()
        if ext in DANGEROUS_EXTENSIONS:
            reasons.append(f"Dangerous executable extension: {ext}")
        elif ext in SUSPICIOUS_EXTENSIONS:
            reasons.append(f"Potentially suspicious extension: {ext}")
        return reasons

    def _clamd_scan(self, file_path: str) -> List[str]:
        reasons: List[str] = []
        if not self._clamd_available:
            return reasons
        try:
            result = self._clamd.scan_file(file_path)
            if result:
                for path, (status, virus_name) in result.items():
                    if status == "FOUND":
                        reasons.append(f"ClamAV: {virus_name}")
        except Exception as exc:
            logger.warning(f"ClamAV scan error: {exc}")
        return reasons

    def _check_office_macros(self, path: Path) -> List[str]:
        reasons: List[str] = []
        if path.suffix.lower() not in {".docm", ".xlsm", ".pptm", ".docx", ".xlsx", ".pptx", ".doc", ".xls", ".ppt"}:
            return reasons
        if not zipfile.is_zipfile(path):
            return reasons
        try:
            with zipfile.ZipFile(path, "r") as z:
                names = z.namelist()
                macro_files = [n for n in names if "vbaProject.bin" in n or "macros" in n.lower()]
                if macro_files:
                    reasons.append(f"Office document contains VBA macros: {macro_files}")
                    # Check macro content for suspicious patterns
                    for mf in macro_files:
                        try:
                            content = z.read(mf)
                            if b"AutoOpen" in content or b"AutoExec" in content:
                                reasons.append("Macro has AutoOpen/AutoExec trigger – high risk")
                            if b"Shell" in content or b"WScript" in content:
                                reasons.append("Macro calls Shell/WScript – suspicious")
                        except Exception:
                            pass
        except Exception as exc:
            logger.debug(f"Office macro check error: {exc}")
        return reasons

    def _check_pdf_javascript(self, path: Path) -> List[str]:
        reasons: List[str] = []
        if path.suffix.lower() != ".pdf":
            return reasons
        try:
            with open(path, "rb") as f:
                content = f.read(1024 * 256)  # read first 256 KB
            if b"/JavaScript" in content or b"/JS " in content:
                reasons.append("PDF has embedded JavaScript")
            if b"/Launch" in content:
                reasons.append("PDF has /Launch action (can execute programs)")
            if b"/OpenAction" in content:
                reasons.append("PDF has /OpenAction (auto-execute on open)")
            if b"/EmbeddedFile" in content:
                reasons.append("PDF has embedded file")
        except Exception as exc:
            logger.debug(f"PDF check error: {exc}")
        return reasons

    def _check_binary_signatures(self, path: Path) -> List[str]:
        reasons: List[str] = []
        try:
            with open(path, "rb") as f:
                header = f.read(512)
            for sig, description in MALWARE_SIGNATURES:
                if sig in header:
                    reasons.append(description)
        except Exception:
            pass
        return reasons

    def _check_suspicious_strings(self, path: Path) -> List[str]:
        reasons: List[str] = []
        if path.suffix.lower() in {".pdf", ".txt", ".html", ".htm", ".xml", ".csv", ".json"}:
            try:
                with open(path, "r", errors="ignore") as f:
                    text = f.read(1024 * 64)  # 64 KB
                patterns = [
                    (r"powershell\s+-(?:enc|command|exec)", "PowerShell encoded command"),
                    (r"cmd\.exe\s+/c", "CMD hidden execution"),
                    (r"WScript\.Shell", "WScript.Shell object (script execution)"),
                    (r"base64_decode\s*\(", "Base64 decoded payload"),
                    (r"eval\s*\(\s*(?:base64_decode|str_rot13|gzinflate)", "Obfuscated eval"),
                ]
                for pattern, description in patterns:
                    if re.search(pattern, text, re.IGNORECASE):
                        reasons.append(description)
            except Exception:
                pass
        return reasons

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def scan_attachment(self, file_path: str) -> Dict:
        """
        Perform multi-layer malware analysis on a file.

        Returns:
            {
                'filename': str,
                'risk': 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW',
                'reasons': [str, ...],
                'is_malware': bool,
                'checks_performed': [str, ...]
            }
        """
        path = Path(file_path)
        checks_performed: List[str] = []
        reasons: List[str] = []

        if not path.exists():
            return {
                "filename": path.name,
                "risk": "LOW",
                "reasons": ["File not found – skipping scan"],
                "is_malware": False,
                "checks_performed": [],
            }

        # 1. Extension check
        reasons += self._check_extension(path)
        checks_performed.append("extension_check")

        # 2. ClamAV
        clamd_hits = self._clamd_scan(file_path)
        reasons += clamd_hits
        checks_performed.append("clamd_scan" if self._clamd_available else "clamd_skipped")

        # 3. Office macros
        reasons += self._check_office_macros(path)
        checks_performed.append("office_macro_check")

        # 4. PDF JavaScript
        reasons += self._check_pdf_javascript(path)
        checks_performed.append("pdf_javascript_check")

        # 5. Binary signatures
        reasons += self._check_binary_signatures(path)
        checks_performed.append("binary_signature_check")

        # 6. Suspicious strings
        reasons += self._check_suspicious_strings(path)
        checks_performed.append("suspicious_string_check")

        # Deduplicate
        reasons = list(dict.fromkeys(reasons))

        # Risk classification
        dangerous_ext = path.suffix.lower() in DANGEROUS_EXTENSIONS
        has_clamd = bool(clamd_hits)
        has_macro = any("macro" in r.lower() or "autopen" in r.lower() for r in reasons)
        has_pdf_js = any("javascript" in r.lower() for r in reasons)

        if dangerous_ext or has_clamd:
            risk = "CRITICAL"
        elif has_macro or has_pdf_js:
            risk = "HIGH"
        elif len(reasons) >= 2:
            risk = "MEDIUM"
        elif len(reasons) == 1:
            risk = "LOW"
        else:
            risk = "LOW"

        is_malware = risk in {"CRITICAL", "HIGH"}

        return {
            "filename": path.name,
            "risk": risk,
            "reasons": reasons if reasons else ["No threats detected"],
            "is_malware": is_malware,
            "checks_performed": checks_performed,
        }

    def get_risk_score(self, file_path: str) -> float:
        """Return normalised 0-100 risk score for fusion model."""
        result = self.scan_attachment(file_path)
        risk_map = {"CRITICAL": 95, "HIGH": 80, "MEDIUM": 45, "LOW": 5}
        return float(risk_map.get(result["risk"], 5))
